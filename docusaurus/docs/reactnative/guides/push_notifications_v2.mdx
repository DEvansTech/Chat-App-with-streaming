---
id: push-notifications-v2
sidebar_position: 2
title: Push Notifications (V2)
---

import chatOverviewPage from '../assets/guides/push-notifications-v2/chat_overview_page.png';
import firebaseNotificationsToggle from '../assets/guides/push-notifications-v2/firebase_notifications_toggle.png';

Easiest way to integrate push notifications in your Chat applications is using Firebase. [React Native Firebase](https://rnfirebase.io/) is the officially recommended package to add Firebase to your apps. We also recommend the [Notifee](https://notifee.app/) library for customising push notifications and listening to user interaction events.

## Requirements

<!-- TODO: Change to new docs for links -->

- Push notifications are sent only for new messages.
- Only channel members receive push messages.
- Members receive push notifications regardless of their online status.
- Replies inside a [thread](https://getstream.io/chat/docs/javascript/threads/?language=javascript) are only sent to users that are part of that thread:
  - They posted at least one message
  - They were mentioned
- Messages from muted users are not sent.
- Messages are sent to all registered devices for a user (up to 25) .
- Up to 100 members of a channel will receive push notifications.
- skip_push is marked as false, as described [here](https://getstream.io/chat/docs/javascript/send_message/?language=javascript#complex-example).
- push_notifications is enabled (default) on the channel type for message is sent.

:::note

- If you would like get push notifications only when users are offline, please contact to support.
- Push notifications require membership. Watching a channel isn't enough.

:::

## Firebase Setup

Follow the steps mentioned on Firebase documentation setup Firebase.

1. [Create a firebase project](https://console.firebase.google.com/).
2. Register your [Android](https://firebase.google.com/docs/android/setup#register-app) app and [iOS](https://firebase.google.com/docs/ios/setup#register-app) app with the Firebase project.
3. Upload your [APNs authentication key](https://firebase.google.com/docs/cloud-messaging/ios/client#upload_your_apns_authentication_key) to your Firebase project.
4. Install React Native Firebase.

   ```sh
   # Install & setup the app module
   yarn add @react-native-firebase/app

   # Install the messaging module
   yarn add @react-native-firebase/messaging
   ```

5. [Setup your Android app with credentials and configure Firebase](https://rnfirebase.io/#2-android-setup).
6. [Setup your iOS app with credentials and configure Firebase](https://rnfirebase.io/#3-ios-setup).

## Get Google Service Account Credentials

Firebase projects support Google service accounts. Credentials obtained via this service account are used by Stream to call Firebase server APIs.

These credentials are the [private key file](https://firebase.google.com/docs/admin/setup#:~:text=To%20generate%20a%20private%20key%20file%20for%20your%20service%20account%3A) for your service account, in Firebase console. To generate a private key file for your service account:

- In the Firebase console, open Settings > Service Accounts.
- Click Generate New Private Key, then confirm by clicking Generate Key.
- Securely store the JSON file containing the key.

This JSON file contains the credentials which needs to be uploaded to Stream server as explained in next step.

## Upload Firebase Credentials

You can upload your JSON file containg your Firebase credentials either using dashboard or using the app settings api:

### Using Dashboard

1. Go to Chat Overview page on Stream Dashboard

<img src={chatOverviewPage} />

2. Enable Firebase Notification toggle on Chat Overview

<img src={firebaseNotificationsToggle} />

3. Enter your Firebase Credentials in input box below the toggle and **press "Save" button**.

### Using API

You can also enable firebase notifications and upload the firebase credentials using api:

```js
const client = StreamChat.getInstance('api_key', 'api_secret');
client.updateAppSettings({
  push_config: {
    version: 'v2'
  },
  firebase_config: {
    credentials_json: fs.readFileSync(
      './firebase-credentials.json',
      'utf-8',
    ),
 });
```

## Registering a device with Stream

Once you configure Firebase server key and set it up on Stream dashboard, a device that is supposed to receive push notifications needs to be registered at Stream backend. This is usually done by listening for Firebase device token.

:::caution

Please note that, `client.addDevice` call requires user token to be set on client.
So `client.addDevice` call should be made after `client.connectUser` in code.

:::

```js
// Request Push Notification permission from device.
const requestPermission = async () => {
  const authStatus = await messaging().requestPermission();
  const enabled =
    authStatus === messaging.AuthorizationStatus.AUTHORIZED || authStatus === messaging.AuthorizationStatus.PROVISIONAL;

  if (enabled) {
    console.log('Authorization status:', authStatus);
  }
};

const App = () => {
  const [isReady, setIsReady] = useState(false);

  useEffect(() => {
    let unsubscribeTokenRefreshListener;
    // Register FCM token with stream chat server.
    const registerPushToken = async () => {
      const token = await messaging().getToken();
      await client.addDevice(token, 'firebase');

      unsubscribeTokenRefreshListener = messaging().onTokenRefresh(async newToken => {
        await client.addDevice(newToken, 'firebase');
      });
    };

    const init = async () => {
      await client.connectUser({ id: USER_ID }, USER_TOKEN);

      await requestPermission();
      await registerPushToken();

      setIsReady(true);
    };

    init();

    return async () => {
      await client?.disconnectUser();
      unsubscribeTokenRefreshListener?.();
    };
  }, []);

  if (!isReady) {
    return null;
  }

  return (
    <View style={styles.container}>
      <Chat client={client}>{/* Child components of Chat go here */}</Chat>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
  },
});
```

## The Push Notification Message Payload

When a message is received by the Chat API, if the [requirements](#requirements) are met, it kicks a job to send a notification message to configured push providers on your app.
According to the battery and the online status of the device, push providers deliver this payload to the actual devices.

The delivered push notification message payload has a `notification` field and a `data` field. The `notification` field is handled by the Firebase SDK to display the message and `data` property should be handled by the app if needed. An example payload is below:

```json
{
  "notification": {
    "title": "Message from user",
    "body": "Hello",
  },
   "data":{
      "sender":"stream.chat",
      "type":"message.new",
      "version":"v2",
      "id":"d152f6c1-8c8c-476d-bfd6-59c15c20548a",
      "channel_type":"messaging",
      "channel_id":"company-chat",
      "cid":"messaging:company-chat"
   },
   // other fields..
}
```

## Listen to user interactions on the notification

The `notification` field is picked up by the Firebase SDK to display the notification when the app is on background or quit state. When a user interacts with the notification by pressing on it, the default behavior is to open the application.

In many cases, it is useful to detect whether the application was opened by pressing on a notification (so you could open a specific screen for example). The [React Native Firebase API](https://rnfirebase.io/messaging/notifications#handling-interaction) provides two APIs for handling interaction:

- `getInitialNotification`: When the application is opened from a quit state.
- `onNotificationOpenedApp`: When the application is running, but in the background.

To handle both scenarios, the code can be executed during setup. For example, using [React Navigation](https://reactnavigation.org/) we can set an initial route when the app is opened from a quit state, and push to a new screen when the app is in a background state:

```js 
import React, { useEffect, useState } from 'react';
import messaging from '@react-native-firebase/messaging';
import { NavigationContainer, NavigationContainerRef } from '@react-navigation/native';
import { createStackNavigator } from '@react-navigation/stack';

const Stack = createStackNavigator();

function App() {
  const navigationContainerRef = useRef<NavigationContainerRef>(null);
  const [initialChannelId, setInitialChannelId] = useState<string>()
  useEffect(() => {
    const unsubscribeOnNotificationOpen = messaging().onNotificationOpenedApp((remoteMessage) => {
      // Notification caused app to open from background state
      const channelId = remoteMessage.data?.channel_id;
      // The navigation logic, to navigate to relevant channel screen.
      if (channelId) {
        navigationContainerRef.current?.navigate('ChannelScreen', { channelId });
      }
    });
    // handle notification clicks on foreground
    const unsubscribeForegroundEvent = notifee.onForegroundEvent(({ detail, type }) => {
      if (type === EventType.PRESS) {
        // user has pressed the foreground notification
        const channelId = detail.notification?.data?.channel_id;
        // The navigation logic, to navigate to relevant channel screen.
        if (channelId) {
          navigationContainerRef.current?.navigate('ChannelScreen', { channelId });
        }
      }
    });

    messaging()
      .getInitialNotification()
      .then(remoteMessage => {
        if (remoteMessage) {
          // Notification caused app to open from quit state
          const channelId = remoteMessage.data?.channel_id;
          // Start the app with the relevant channel screen.
          setInitialChannelId(channelId)
        }
    });
    
    return () => {
      unsubscribeOnNotificationOpen();
      unsubscribeForegroundEvent();
    };
  }, []);

  return (
    <NavigationContainer ref={navigationContainerRef}>
      <Stack.Navigator initialRouteName={initialChannelId ? "ChannelScreen" : "Home"}>
        <Stack.Screen name='Home' component={HomeScreen} />
        <Stack.Screen name='ChannelListScreen' component={ChannelListScreen} />
        <Stack.Screen name='ChannelScreen'
          component={ChannelScreen}
          initialParams={initialChannelId ? { channelId: initialChannelId } : undefined}
        />
      </Stack.Navigator>
    </NavigationContainer>
  );
}
```

### Listening to notifications on the background

To listen to notifications on the background we can use the [`setBackgroundMessageHandler`](https://rnfirebase.io/messaging/usage#background--quit-state-messages) method.

:::caution

This method works only on Android. On iOS, if a payload contains the `notification` it is expected to be handled on user interactions using the callbacks mentioned in the previous section. However, if we do want to customise the notification or set the badge number on iOS, we will need to implement a [`Notification Service Extension`](https://developer.apple.com/documentation/usernotifications/unnotificationserviceextension) in the native language.

:::

To setup a background handler, call the `setBackgroundMessageHandler` outside of your application logic as early as possible:

```jsx
// index.js
import { AppRegistry } from 'react-native';
import messaging from '@react-native-firebase/messaging';
import { StreamChat } from 'stream-chat';

messaging().setBackgroundMessageHandler(async remoteMessage => {
  const client = StreamChat.getInstance('api_key');

  // You can also provide tokenProvider instead of static token 
  // await client._setToken({ id: userId }, tokenProvider)
  client._setToken(
    {
      id: 'user_id',
    },
    'user_token',
  );
  // handle the message
  const message = await client.getMessage(remoteMessage.data.id);
});

function App() {
  // Your application
}

AppRegistry.registerComponent('app', App);
```

## Display Notification In Foreground

As mentioned before, the Firebase SDK automatically displays the message to the user using the `notification` property when the app is not on foreground. But if we do want to display the notification in the foreground, we can listen to messages using the [`onMessage`](https://rnfirebase.io/messaging/usage#foreground-state-messages) callback inside of your application code and display a notification to end user. Code executed via this handler has access to React context and is able to interact with your application (e.g. updating the state or UI).

:::note

Generally chat applications don't show push notifications when the app is the foreground, so you may want to ignore this step depending on your product requirement.

:::

```jsx
import messaging from '@react-native-firebase/messaging';
import notifee from '@notifee/react-native';

useEffect(() => {
  // add listener to notifications received when on foreground
  const unsubscribeOnMessage = messaging().onMessage(async remoteMessage => {
    const message = await chatClient.getMessage(remoteMessage.data.id);

    // create the android channel to send the notification to
    const channelId = await notifee.createChannel({
      id: 'chat-messages',
      name: 'Chat Messages',
    });

    // display the notification
    await notifee.displayNotification({
      title: message.message.text,
      body: message.message.text,
      android: {
        channelId: 'chat-messages',
        pressAction: {
          id: 'default',
        },
      body: message.message.text,
      data: remoteMessage.data,
      title: 'New message from ' + message.message.user.name,
      },
    });
  });

  // add listener to user interactions on foreground notifications
  const unsubscribeForegroundEvent = notifee.onForegroundEvent(({ detail, type }) => {
    if (type === EventType.PRESS) {
      // user has pressed notification
      const channelId = detail.notification?.data?.channel_id;
      // navigate using the channel id using your app's navigation logic
      navigateToChannelScreen(channelId)
    }
  })

  return () => {
    unsubscribeOnMessage();
    unsubscribeForegroundEvent();
  }
}, []);
```
