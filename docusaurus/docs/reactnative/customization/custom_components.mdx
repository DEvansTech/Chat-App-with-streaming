---
id: custom_components
sidebar_position: 4
title: Custom Components
---

import dateHeader from '../assets/customization/custom-components/date_header.png'
import nameDateHeader from '../assets/customization/custom-components/name_date_header.png'
import newDateHeader from '../assets/customization/custom-components/new_date_header.png'
import noDateHeader from '../assets/customization/custom-components/no_date_header.png'

The core of Stream Chat for React Native is it's ability to be customized to your needs.
Many developers find that simply altering [the theme](./theming.mdx) is enough to achieve their desired results.
But if more modification is needed, or functionality beyond what is provided out of the box is desired, creating a custom component is likely the best course of action.

## When to use a custom component

Understanding what is customizable is helpful in determining when to build a custom component.
If you want to insert your component(s) into another component, you need to create a custom component.
If you want to change the layout of a component significantly, you need to create a custom component.
If you want to change the internal functionality of a component, you need to create a custom component.
A good way to think about it is, with few exceptions, what you see is what you get.
We can't account for every possible use case out of the box, but don't worry building and using custom components is easy!

### Exceptions

- Paddings, fonts, colors, borders, etc. can all be altered from the [the theme](./theming.mdx) as styles are passed to most components and sub-components.
- You can align all messages to one side using the `forceAlignMessages` prop on the `Channel` component.
- And you can reorder message content using the `messageContentOrder` prop on `Channel`; but you may want to adjust the theming to account for changes to border alignments if you alter this order.

Changes to content beyond these tweaks will require custom components.
If your goal is simply to remove a UI feature you can always replace the component with one that returns `null` to achieve this, i.e. `() => null`.

## How to use a custom component

Most custom components are provided to the UI as props on the `Channel` component.
The `OverlayProvider`, `MessageList`, and `ChannelList` have a few exceptions to this rule, but `Channel` is the primary entry point.

Let's say you want to remove the fixed `DateHeader` on the message list.
We can create a component that returns `null` and pass it in as out `DateHeader` on `Channel`.

```tsx
const MyEmptyComponent = () => null;

<Channel
  ...
  DateHeader={MyEmptyComponent}
>
```

The new custom component takes the place of the default `DateHeader` within our context and is then used and rendered wherever the default `DateHeader` currently is.
We can just as easily swap the component out for one that renders something different than the original.
Most components rely on context for receiving data, but some use props instead or as well.
In the case of `DateHeader` the component will be rendered with the prop `dateString` which is a `string`.

```tsx
const MyNewComponent = ({ dateString }) => <Text>{`Hello World: ${dateString}`}</Text>;

<Channel
  ...
  DateHeader={MyNewComponent}
>
```

<div style={{ display: 'flex', flexWrap: 'wrap', justifyContent: 'space-around' }}>
<div style={{ position: 'relative' }}>
<div style={{ left: '110px', top: '65px', position: 'absolute', height: '30px', width: '60px', borderColor: '#fa383e', borderWidth: '4px', borderRadius: '15px', borderStyle: 'solid' }}></div>
<img src={dateHeader} alt="DateHeader" width="280" style={{ objectFit: 'contain', paddingBottom: '8px' }} />
</div>
<img src={noDateHeader} alt="NoDateHeader" width="280" style={{ objectFit: 'contain', paddingBottom: '8px' }} />
<div style={{ position: 'relative' }}>
<div style={{ left: '90px', top: '65px', position: 'absolute', height: '20px', width: '100px', borderColor: '#fa383e', borderWidth: '4px', borderRadius: '15px', borderStyle: 'solid' }}></div>
<img src={newDateHeader} alt="NewDateHeader" width="280" style={{ objectFit: 'contain', paddingBottom: '8px' }} />
</div>
</div>

## Using contexts

At the core of creating custom components is the ability to access pertinent data from the contexts Stream Chat for React Native provides.
[The hooks](./contexts.mdx#hooks) provided allow you to access this contextual information easily throughout your application.
Keep in mind when developing that these hooks are only usable within the scope of their context providers.
Certain contexts, such at `MessageContext`, are only available within the scope of a single `Message` so you cannot use this hook in for instance the `DateHeader`.

To demonstrate this usage we can replace our `DateHeader` with a component that makes use of context.
We can pull messages from the `PaginatedMessageListContext` and get the name of the last sender from the list and display it in place of the `DateHeader`.

```tsx
const MySenderComponent = () => {
  const { messages } = usePaginatedMessageListContext();
  const latestMessageSender = messages[messages.length - 1]?.user?.name;

  return <Text>{`Last Sender: ${latestMessageSender}`}</Text>;
};

<Channel
  ...
  DateHeader={MySenderComponent}
>
```

<div style={{ display: 'flex', justifyContent: 'space-around' }}>
<div style={{ position: 'relative' }}>
<div style={{ left: '90px', top: '65px', position: 'absolute', height: '20px', width: '100px', borderColor: '#fa383e', borderWidth: '4px', borderRadius: '15px', borderStyle: 'solid' }}></div>
<img src={nameDateHeader} alt="NameDateHeader" width="280" style={{ objectFit: 'contain', paddingBottom: '8px' }} />
</div>
</div>

This allows you as a developer to not only customize the look and feel of every part of the UI, but also decide what information is shown where based on your own design.

:::caution

Custom components within a `Message` should draw from mostly static contexts with the exception of their own `MessageContext`.
`ThemeContext`, `MessagesContext`, and `TranslationContext` all remain static with few exceptions and can be used.

This should be done as memoization of a value from a context surrounding the [`FlatList`](https://reactnative.dev/docs/flatlist) from a component within the `FlatList` does not work properly when the context updates.
Pulling directly from the `PaginatedMessageListContext` within a `Message` for instance would cause every `Message` to re-render to some degree when the message list updates.

:::

## Performance

If a value in a context updates [all components accessing values from that context will re-render](https://reactjs.org/docs/context.html#contextprovider), even if the values they are accessing have not changed.
Many of the out of the box components use memoization with custom `areEqual` checks to ensure components are only being re-rendered when necessary.
Values from context are passed through the memoization as props and the necessity to re-render is determined.
This is most important inside of messages where the largest performance hit would be noticeable as an update that re-renders every message is computationally expensive.

When creating custom components we suggest that developers take the same performance considerations to ensure the user experience is not degraded.
If we add a console log to a custom `DateHeader` component that is accessing the `PaginatedMessageListContext` we see a large number of re-renders when the channel mounts, and continue to see more re-renders when interacting with messages, such as reacting to one.

```tsx
const MySenderComponent = () => {
  const { messages } = usePaginatedMessageListContext();
  const latestMessageSender = messages[messages.length - 1]?.user?.name;
  console.log('Render.');

  return <Text>{`Last Sender: ${latestMessageSender}`}</Text>;
};
```

To reduce these re-renders we can break the component apart into a component that consumes context, and a component that is memoized and takes only props.
We can then use a custom `areEqual` check in the memoization to determine if the component should re-render.

```tsx
const MySenderComponentWithContext = ({ latestMessageSender }) => {
  console.log('Rendered');

  return <Text>{`Last Sender: ${latestMessageSender}`}</Text>;
};

const MemoizedMySenderComponent = React.memo(
  MySenderComponentWithContext,
  (prev, next) => prev.latestMessageSender === next.latestMessageSender,
);

const MySenderComponent = () => {
  const { messages } = usePaginatedMessageListContext();
  const latestMessageSender = messages[messages.length - 1]?.user?.name;

  return <MemoizedMySenderComponent latestMessageSender={latestMessageSender} />;
};
```

Following this pattern we see `MySenderComponentWithContext`, and therefore the UI component `Text`, render only one time.
The check on `latestMessageSender` will ensure the component re-renders when `latestMessageSender` changes, but otherwise will not.
We can react to, edit, delete, or add a message, and the component will not re-render until the sender of the latest message changes.

There are many custom equality checks like this in the out of the box components.
When creating a custom component we always suggest **looking at the source code of the component you are replacing**.
If you use the original component as a base for your custom component you can ensure the performance of your custom component matches that of the original, and easily see which contexts data is being drawn from.
